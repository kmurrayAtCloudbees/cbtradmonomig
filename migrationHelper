pipeline {
    agent {
        label 'cb-migration'
    }

    parameters {
        string(name: 'SOURCE_CONFIG', description: 'Folder name representing the source controller (used for file structure and branch naming)')
        string(name: 'CB_HOME', description: 'Path to JENKINS_HOME on source')
        string(name: 'SSH_CREDENTIAL_ID', description: 'Credential ID for SSH private key')
        string(name: 'MULTI_TARGETS', description: 'Comma-separated list of controller:IP pairs')
        booleanParam(name: 'PLAN_DRY_RUN', description: 'Plan only: generate includes/assignments. No Git push or PR.')
        booleanParam(name: 'DRY_RUN', description: 'Perform rsync with --dry-run')
        booleanParam(name: 'INCLUDE_BUILD_LOGS', description: 'Include build logs during rsync')
        booleanParam(name: 'RELOAD_TARGET', description: 'Reload target Jenkins instance after sync')
        booleanParam(name: 'DISABLE_SOURCE_JOBS_AFTER_MIGRATION', description: 'Disable source jobs after migration')
        booleanParam(name: 'QUIET_DOWN_SOURCE', description: 'Put source controller into Quiet Down before final sync')
        booleanParam(name: 'AUTO_CREATE_PR', description: 'Automatically create a GitHub pull request after Git push')
        string(name: 'MODE', description: 'dry-run | inactive | delta')
        string(name: 'MAX_FAILURES', description: 'Max allowed failures before abort')
    }
  

    environment {
        ASSIGNMENTS_FILE = "assignments.csv"
        FAILURE_COUNT = 0
    }

    stages {
        stage('Validate Parameters') {
            steps {
                script {
                    def errors = []
                    
                    // Required string parameters
                    if (!params.SOURCE_CONFIG || params.SOURCE_CONFIG.trim().isEmpty()) {
                        errors << "SOURCE_CONFIG is required"
                    }
                    
                    if (!params.CB_HOME || params.CB_HOME.trim().isEmpty()) {
                        errors << "CB_HOME is required"
                    }
                    
                    if (!params.SSH_CREDENTIAL_ID || params.SSH_CREDENTIAL_ID.trim().isEmpty()) {
                        errors << "SSH_CREDENTIAL_ID is required"
                    }
                    
                    if (!params.MULTI_TARGETS || params.MULTI_TARGETS.trim().isEmpty()) {
                        errors << "MULTI_TARGETS is required"
                    }
                    
                    if (!params.MODE || params.MODE.trim().isEmpty()) {
                        errors << "MODE is required"
                    }
                    
                    if (!params.MAX_FAILURES || params.MAX_FAILURES.trim().isEmpty()) {
                        errors << "MAX_FAILURES is required"
                    }
                    
                    // Validate MODE values
                    def validModes = ['dry-run', 'inactive', 'delta']
                    if (params.MODE && !validModes.contains(params.MODE)) {
                        errors << "MODE must be one of: ${validModes.join(', ')}"
                    }
                    
                    // Validate MULTI_TARGETS format
                    if (params.MULTI_TARGETS) {
                        try {
                            def targets = params.MULTI_TARGETS.split(',')
                            targets.each { target ->
                                if (!target.contains(':')) {
                                    errors << "MULTI_TARGETS format error: '${target}' must be 'name:ip'"
                                }
                            }
                        } catch (Exception e) {
                            errors << "MULTI_TARGETS format error: ${e.message}"
                        }
                    }
                    
                    // Validate MAX_FAILURES is numeric
                    if (params.MAX_FAILURES) {
                        try {
                            Integer.parseInt(params.MAX_FAILURES)
                        } catch (NumberFormatException e) {
                            errors << "MAX_FAILURES must be a number"
                        }
                    }
                    
                    // Validate CB_HOME path format
                    if (params.CB_HOME && !params.CB_HOME.startsWith('/')) {
                        errors << "CB_HOME must be an absolute path starting with '/'"
                    }
                    
                    // Display all parameter values for verification
                    echo "=== PARAMETER VALIDATION ==="
                    echo "SOURCE_CONFIG: '${params.SOURCE_CONFIG}'"
                    echo "CB_HOME: '${params.CB_HOME}'"
                    echo "SSH_CREDENTIAL_ID: '${params.SSH_CREDENTIAL_ID}'"
                    echo "MULTI_TARGETS: '${params.MULTI_TARGETS}'"
                    echo "PLAN_DRY_RUN: ${params.PLAN_DRY_RUN}"
                    echo "DRY_RUN: ${params.DRY_RUN}"
                    echo "INCLUDE_BUILD_LOGS: ${params.INCLUDE_BUILD_LOGS}"
                    echo "RELOAD_TARGET: ${params.RELOAD_TARGET}"
                    echo "DISABLE_SOURCE_JOBS_AFTER_MIGRATION: ${params.DISABLE_SOURCE_JOBS_AFTER_MIGRATION}"
                    echo "QUIET_DOWN_SOURCE: ${params.QUIET_DOWN_SOURCE}"
                    echo "AUTO_CREATE_PR: ${params.AUTO_CREATE_PR}"
                    echo "MODE: '${params.MODE}'"
                    echo "MAX_FAILURES: '${params.MAX_FAILURES}'"
                    echo "=========================="
                    
                    // Fail if any validation errors
                    if (errors.size() > 0) {
                        echo "VALIDATION FAILED:"
                        errors.each { error ->
                            echo "  ❌ ${error}"
                        }
                        error("Parameter validation failed. Please correct the above errors and try again.")
                    } else {
                        echo "✅ All parameters validated successfully"
                    }
                }
            }
        }
        stage('Validate Target Controller Connectivity') {
            steps {
                script {
                    def controllers = params.MULTI_TARGETS.split(',').collect { it.split(':')[1].trim() }

                    controllers.each { controllerIp ->
                        echo "Testing SSH connection to ${controllerIp}"

                        withCredentials([sshUserPrivateKey(credentialsId: "${params.SSH_CREDENTIAL_ID}", keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')]) {
                            sh "ssh -i \$SSH_KEY -o StrictHostKeyChecking=no \$SSH_USER@${controllerIp} 'echo Connected to \$(hostname)'"
                            sh "ssh -i \$SSH_KEY -o StrictHostKeyChecking=no \$SSH_USER@${controllerIp} 'echo JENKINS_HOME=\$JENKINS_HOME'"
                        }

                        echo "SSH test to ${controllerIp} completed successfully"
                    }
                }
            }
        }
        
        stage('Clean Workspace') {
            steps {
                cleanWs()
            }
        }

        stage('Generate Migration Plan Files') {
            steps {
                script {
                    echo "Generating migration plan using shared library..."

                    def migrationResults = generateMigrationFiles([
                        parentFolderPath: "",
                        migrationDepth: 0,
                        activityThresholdDays: 180,
                        targetControllers: params.MULTI_TARGETS.split(',').collect { it.split(':')[0].trim() },
                        outputDir: "${params.SOURCE_CONFIG}",
                        verbose: true,
                        dryRun: false,
                        excludePatterns: ['**/test-*', '**/sandbox/*']
                    ])

                    echo "Migration Plan Generated:"
                    echo " - Jobs Analyzed: ${migrationResults.stats.totalJobs}"
                    echo " - Assignments: ${migrationResults.assignments.size()}"
                    echo " - Output Directory: ${params.SOURCE_CONFIG}"

                    if (params.PLAN_DRY_RUN) {
                        echo "[PLAN_DRY_RUN] Skipping Git operations."
                        sh """
                            echo 'Preview of assignments.csv:'
                            head -n 10 ${params.SOURCE_CONFIG}/assignments.csv || echo 'No file found'
                        """
                    }
                }
            }
        }

stage('Commit and Push Migration Plan') {
            when {
                expression { return !params.PLAN_DRY_RUN }
            }
            steps {
                script {
                    def timestamp = new Date().format('yyyyMMdd-HHmmss')
                    def branchName = "${params.SOURCE_CONFIG}-${timestamp}"
                    env.MIGRATION_BRANCH = branchName
                    echo "Creating new branch '${branchName}' and pushing migration files..."
                }
                
                sh "git config user.email 'jenkins@migration.mail'"
                sh "git config user.name 'Jenkins Migration Pipeline'"
                sh "git checkout -b \${MIGRATION_BRANCH}"
                sh "git add ${params.SOURCE_CONFIG}/"
                sh "git commit -m 'Migration plan for ${params.SOURCE_CONFIG} - \${BUILD_TIMESTAMP}'"
                sh "git push origin \${MIGRATION_BRANCH}"
                
                script {
                    // Get the commit hash for reference  
                    def commitHash = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
                    env.COMMIT_HASH = commitHash

                    echo "====== MIGRATION PLAN PUSHED ======"
                    echo "Branch: ${env.MIGRATION_BRANCH}"
                    echo "Commit Hash: ${commitHash}"
                    echo "Repository: ${env.GIT_URL ?: env.GIT_URL_1}"
                    echo "Files pushed to: ${params.SOURCE_CONFIG}/"
                    echo "====================================="
                }
            }
        }

        stage('Manual PR Review and Approval') {
            when {
                expression { return !params.PLAN_DRY_RUN }
            }
            steps {
                script {
                    echo "Branch: ${env.MIGRATION_BRANCH}"
                    echo "Commit: ${env.COMMIT_HASH}"
                    echo "Review the migration files and create a PR"
                }
                
                // Input step outside script block
                timeout(time: 60, unit: 'MINUTES') {
                    input message: "After creating and merging PR, choose action:",
                        ok: 'Submit',
                        submitterParameter: 'APPROVER',
                        parameters: [
                            choice(name: 'ACTION', 
                                    choices: ['Continue Migration', 'Stop Process'], 
                                    description: 'Action after PR review')
                        ]
                }
                
                script {
                    if (params.ACTION == 'Stop Process') {
                        error("Migration stopped by user")
                    }
                    echo "Continuing with migration..."
                }
            }
        }

        stage('Execute Migration') {
            when {
                expression { return !params.PLAN_DRY_RUN }
            }
            steps {
                script {
                    def assignmentFile = "${params.SOURCE_CONFIG}/${env.ASSIGNMENTS_FILE}"
                    def assignments = []

                    if (fileExists(assignmentFile)) {
                        def raw = readFile(assignmentFile).split('\n')
                        assignments = raw.size() > 1 ? raw[1..-1].findAll { it.trim() }.collect { it.split(',') } : []
                        echo "Loaded ${assignments.size()} assignments from ${assignmentFile}"
                    } else {
                        error "assignments.csv not found at ${assignmentFile}"
                    }

                    def targets = params.MULTI_TARGETS.split(',').collectEntries {
                        def (name, ip) = it.trim().split(':')
                        [(name): ip]
                    }

                    assignments.each { row ->
                        def jobPath = row[0].trim()
                        def targetController = row[1].trim()

                        if (!targets.containsKey(targetController)) {
                            error "Controller '${targetController}' in assignments.csv is not listed in MULTI_TARGETS"
                        }

                        def controllerIp = targets[targetController]
                        def sourcePath = "${params.CB_HOME}/jobs/${jobPath}"
                        def targetPath = "${params.CB_HOME}/jobs/${jobPath}"

                        def rsyncCmd = "rsync -az --delete ${sourcePath}/ ${targetController}:${targetPath}/"

                        if (params.DRY_RUN) {
                            rsyncCmd += " --dry-run --stats"
                        }

                        if (!params.INCLUDE_BUILD_LOGS) {
                            rsyncCmd += " --exclude='**/builds/*/log' --exclude='**/*.log'"
                        }

                        echo "[SIMULATION] Would run rsync for job folder:"
                        echo "  Source path: ${sourcePath}"
                        echo "  Target     : ${targetController} ⇨ ${controllerIp}"
                        echo "  Rsync cmd  : ${rsyncCmd}"
                        
                        // Simulated rsync — real command is disabled
                        // sh rsyncCmd

                        if (params.RELOAD_TARGET) {
                            echo "[SIMULATION] Would reload Jenkins on target controller ${targetController}"
                        }

                        if (params.DISABLE_SOURCE_JOBS_AFTER_MIGRATION) {
                            echo "[SIMULATION] Would disable source job: ${jobPath}"
                        }
                    }
                }
            }
        }

        stage('Migration Summary and Status') {
            steps {
                script {
                    def assignmentFile = "${params.SOURCE_CONFIG}/${env.ASSIGNMENTS_FILE}"
                    def assignmentCount = 0
                    def controllerTargets = []

                    if (fileExists(assignmentFile)) {
                        def raw = readFile(assignmentFile).split('\n')
                        def assignments = raw.size() > 1 
                            ? raw[1..-1].findAll { it.trim() }.collect { it.split(',') }
                            : []
                        assignmentCount = assignments.size()
                        controllerTargets = assignments.collect { it[1].trim() }.unique().sort()
                    }

                    echo "[SUMMARY] Mode: ${params.MODE}"
                    echo "[SUMMARY] DRY_RUN: ${params.DRY_RUN}"
                    echo "[SUMMARY] Plan Only: ${params.PLAN_DRY_RUN}"
                    echo "[SUMMARY] Total Assignments: ${assignmentCount}"
                    echo "[SUMMARY] Target Controllers: ${controllerTargets.join(', ')}"
                    echo "[SUMMARY] Failures: ${env.FAILURE_COUNT}"
                }
            }
        }
    }
    post {
        success {
            echo "[DONE] Migration pipeline completed successfully."
        }
        failure {
            echo "[ERROR] Migration failed. Check logs for details."
        }
    }
}