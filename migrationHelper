pipeline {
    agent {
        label 'cb-migration'
    }

    parameters {
        string(name: 'SOURCE_CONFIG', defaultValue: 'source-controller-vcps-monolith', description: 'Folder name representing the source controller (used for file structure and branch naming)')
        string(name: 'CB_HOME', defaultValue: '/vcps_jenkins/jenkins_homes/vcps-monolith', description: 'Path to JENKINS_HOME on source')
        string(name: 'SSH_CREDENTIAL_ID', defaultValue: 'controllerssh', description: 'Credential ID for SSH private key')
        string(name: 'MULTI_TARGETS', defaultValue: 'controllerSource:192.168.4.241,controllerTarget:192.168.4.242', description: 'Comma-separated list of controller:IP pairs')
        booleanParam(name: 'PLAN_DRY_RUN', defaultValue: true, description: 'Plan only: generate includes/assignments. No Git push or PR.')
        booleanParam(name: 'DRY_RUN', defaultValue: true, description: 'Perform rsync with --dry-run')
        booleanParam(name: 'INCLUDE_BUILD_LOGS', defaultValue: true, description: 'Include build logs during rsync')
        booleanParam(name: 'RELOAD_TARGET', defaultValue: false, description: 'Reload target Jenkins instance after sync')
        booleanParam(name: 'DISABLE_SOURCE_JOBS_AFTER_MIGRATION', defaultValue: false, description: 'Disable source jobs after migration')
        booleanParam(name: 'QUIET_DOWN_SOURCE', defaultValue: false, description: 'Put source controller into Quiet Down before final sync')
        booleanParam(name: 'AUTO_CREATE_PR', defaultValue: true, description: 'Automatically create a GitHub pull request after Git push')
        string(name: 'MODE', defaultValue: 'dry-run', description: 'dry-run | inactive | delta')
        string(name: 'MAX_FAILURES', defaultValue: '10', description: 'Max allowed failures before abort')
    }

    environment {
        ASSIGNMENTS_FILE = "assignments.csv"
        FAILURE_COUNT = 0
    }

    stages {

        stage('Validate Target Controller Connectivity') {
            steps {
                script {
                    def controllers = params.MULTI_TARGETS.split(',').collect { it.split(':')[1].trim() }

                    controllers.each { controllerIp ->
                        echo "Testing SSH connection to ${controllerIp}"

                        withCredentials([sshUserPrivateKey(credentialsId: "${params.SSH_CREDENTIAL_ID}", keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')]) {
                            sh "ssh -i \$SSH_KEY -o StrictHostKeyChecking=no \$SSH_USER@${controllerIp} 'echo Connected to \$(hostname)'"
                            sh "ssh -i \$SSH_KEY -o StrictHostKeyChecking=no \$SSH_USER@${controllerIp} 'echo JENKINS_HOME=\$JENKINS_HOME'"
                        }

                        echo "SSH test to ${controllerIp} completed successfully"
                    }
                }
            }
        }

        stage('Generate Migration Plan Files') {
            steps {
                script {
                    echo "Generating migration plan using shared library..."

                    def migrationResults = generateMigrationFiles([
                        parentFolderPath: "",
                        migrationDepth: 0,
                        activityThresholdDays: 180,
                        targetControllers: params.MULTI_TARGETS.split(',').collect { it.split(':')[0].trim() },
                        outputDir: "${params.SOURCE_CONFIG}",
                        verbose: true,
                        dryRun: false,
                        excludePatterns: ['**/test-*', '**/sandbox/*']
                    ])

                    echo "Migration Plan Generated:"
                    echo " - Jobs Analyzed: ${migrationResults.stats.totalJobs}"
                    echo " - Assignments: ${migrationResults.assignments.size()}"
                    echo " - Output Directory: ${params.SOURCE_CONFIG}"

                    if (params.PLAN_DRY_RUN) {
                        echo "[PLAN_DRY_RUN] Skipping Git operations."
                        sh """
                            echo 'Preview of assignments.csv:'
                            head -n 10 ${params.SOURCE_CONFIG}/assignments.csv || echo 'No file found'
                        """
                    }
                }
            }
        }

stage('Commit and Push Migration Plan') {
            when {
                expression { return !params.PLAN_DRY_RUN }
            }
            steps {
                script {
                    def timestamp = new Date().format('yyyyMMdd-HHmmss')
                    def branchName = "${params.SOURCE_CONFIG}-${timestamp}"
                    env.MIGRATION_BRANCH = branchName
                    echo "Creating new branch '${branchName}' and pushing migration files..."
                }
                
                sh "git config user.email 'jenkins@migration.mail'"
                sh "git config user.name 'Jenkins Migration Pipeline'"
                sh "git checkout -b \${MIGRATION_BRANCH}"
                sh "git add ${params.SOURCE_CONFIG}/"
                sh "git commit -m 'Migration plan for ${params.SOURCE_CONFIG} - \${BUILD_TIMESTAMP}'"
                sh "git push origin \${MIGRATION_BRANCH}"
                
                script {
                    // Get the commit hash for reference  
                    def commitHash = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
                    env.COMMIT_HASH = commitHash

                    echo "====== MIGRATION PLAN PUSHED ======"
                    echo "Branch: ${env.MIGRATION_BRANCH}"
                    echo "Commit Hash: ${commitHash}"
                    echo "Repository: ${env.GIT_URL ?: env.GIT_URL_1}"
                    echo "Files pushed to: ${params.SOURCE_CONFIG}/"
                    echo "====================================="
                }
            }
        }

        stage('Manual PR Review and Approval') {
            when {
                expression { return !params.PLAN_DRY_RUN }
            }
            steps {
                timeout(time: 60, unit: 'MINUTES') {
                    script {
                        def branchName = env.MIGRATION_BRANCH
                        def commitHash = env.COMMIT_HASH
                        def gitUrl = env.GIT_URL ?: env.GIT_URL_1
                        
                        // Extract GitHub repo for PR URL
                        def repoMatch = gitUrl =~ /[:\/]([^\/]+\/[^\/]+?)(\.git)?$/
                        def repoId = repoMatch ? repoMatch[0][1] : "unknown/repo"
                        def prUrl = "https://github.com/${repoId}/compare/main...${branchName}"

                        echo "=========================================="
                        echo "MANUAL REVIEW REQUIRED"
                        echo "=========================================="
                        echo "Branch: ${branchName}"
                        echo "Commit: ${commitHash}"
                        echo "Create PR at: ${prUrl}"
                        echo ""
                        echo "Migration files generated:"
                        echo "- ${params.SOURCE_CONFIG}/active.txt"
                        echo "- ${params.SOURCE_CONFIG}/inactive.txt" 
                        echo "- ${params.SOURCE_CONFIG}/combined.txt"
                        echo "- ${params.SOURCE_CONFIG}/assignments.csv"
                        echo "- ${params.SOURCE_CONFIG}/excludes.txt"
                        echo ""
                        echo "Next Steps:"
                        echo "1. Review the pushed migration files in the branch"
                        echo "2. Create a Pull Request using the URL above"
                        echo "3. Have team review and merge the PR"
                        echo "4. Click 'Proceed' below to continue migration"
                        echo "=========================================="

                        // Manual approval step with choices
                        def userChoice = input message: """
Migration plan has been pushed to branch: ${branchName}

Create PR at: ${prUrl}

After reviewing the migration files, choose an option:
""", 
                        ok: 'Submit',
                        submitterParameter: 'APPROVER',
                        parameters: [
                            choice(
                                name: 'ACTION', 
                                choices: ['Merge Complete - Continue Migration', 'End Process - Resolve Issues'], 
                                description: 'Select action after reviewing migration plan'
                            )
                        ]
                        
                        echo "Action selected by ${env.APPROVER}: ${userChoice.ACTION}"
                        
                        if (userChoice.ACTION == 'End Process - Resolve Issues') {
                            echo "Migration process stopped by user request."
                            echo "Branch ${branchName} remains available for further review."
                            error("Migration halted: User selected 'End Process - Resolve Issues'")
                        } else {
                            echo "Proceeding with migration execution..."
                        }
                    }
                }
            }
        }

        stage('Execute Migration') {
            when {
                expression { return !params.PLAN_DRY_RUN }
            }
            steps {
                script {
                    def assignmentFile = "${params.SOURCE_CONFIG}/${env.ASSIGNMENTS_FILE}"
                    def assignments = []

                    if (fileExists(assignmentFile)) {
                        def raw = readFile(assignmentFile).split('\n')
                        assignments = raw.tail().findAll { it.trim() }.collect { it.split(',') }
                        echo "Loaded ${assignments.size()} assignments from ${assignmentFile}"
                    } else {
                        error "assignments.csv not found at ${assignmentFile}"
                    }

                    def targets = params.MULTI_TARGETS.split(',').collectEntries {
                        def (name, ip) = it.trim().split(':')
                        [(name): ip]
                    }

                    assignments.each { row ->
                        def jobPath = row[0].trim()
                        def targetController = row[1].trim()

                        if (!targets.containsKey(targetController)) {
                            error "Controller '${targetController}' in assignments.csv is not listed in MULTI_TARGETS"
                        }

                        def controllerIp = targets[targetController]
                        def sourcePath = "${params.CB_HOME}/jobs/${jobPath}"
                        def targetPath = "${params.CB_HOME}/jobs/${jobPath}"

                        def rsyncCmd = "rsync -az --delete ${sourcePath}/ ${targetController}:${targetPath}/"

                        if (params.DRY_RUN) {
                            rsyncCmd += " --dry-run --stats"
                        }

                        if (!params.INCLUDE_BUILD_LOGS) {
                            rsyncCmd += " --exclude='**/builds/*/log' --exclude='**/*.log'"
                        }

                        echo "[SIMULATION] Would run rsync for job folder:"
                        echo "  Source path: ${sourcePath}"
                        echo "  Target     : ${targetController} ⇨ ${controllerIp}"
                        echo "  Rsync cmd  : ${rsyncCmd}"
                        
                        // Simulated rsync — real command is disabled
                        // sh rsyncCmd

                        if (params.RELOAD_TARGET) {
                            echo "[SIMULATION] Would reload Jenkins on target controller ${targetController}"
                        }

                        if (params.DISABLE_SOURCE_JOBS_AFTER_MIGRATION) {
                            echo "[SIMULATION] Would disable source job: ${jobPath}"
                        }
                    }
                }
            }
        }

        stage('Migration Summary and Status') {
            steps {
                script {
                    def assignmentFile = "${params.SOURCE_CONFIG}/${env.ASSIGNMENTS_FILE}"
                    def assignmentCount = 0
                    def controllerTargets = []

                    if (fileExists(assignmentFile)) {
                        def raw = readFile(assignmentFile).split('\n')
                        def assignments = raw.size() > 1 
                            ? raw[1..-1].findAll { it.trim() }.collect { it.split(',') }
                            : []
                        assignmentCount = assignments.size()
                        controllerTargets = assignments.collect { it[1].trim() }.unique().sort()
                    }

                    echo "[SUMMARY] Mode: ${params.MODE}"
                    echo "[SUMMARY] DRY_RUN: ${params.DRY_RUN}"
                    echo "[SUMMARY] Plan Only: ${params.PLAN_DRY_RUN}"
                    echo "[SUMMARY] Total Assignments: ${assignmentCount}"
                    echo "[SUMMARY] Target Controllers: ${controllerTargets.join(', ')}"
                    echo "[SUMMARY] Failures: ${env.FAILURE_COUNT}"
                }
            }
        }
    }
    post {
        success {
            echo "[DONE] Migration pipeline completed successfully."
        }
        failure {
            echo "[ERROR] Migration failed. Check logs for details."
        }
    }
}