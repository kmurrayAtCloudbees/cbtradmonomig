pipeline {
    agent {
        label 'cb-migration'
    }

parameters {
    string(name: 'SOURCE_CONFIG', description: 'Folder name representing the source controller (used for file structure and branch naming)')
    string(name: 'CB_HOME', description: 'Path to JENKINS_HOME on source')
    string(name: 'SSH_CREDENTIAL_ID', description: 'Credential ID for SSH private key')
    string(name: 'MULTI_TARGETS', description: 'Comma-separated list of controller:IP pairs')
    choice(name: 'MODE', 
           choices: [
               'plan-only', 
               'test-migration', 
               'safe-migration', 
               'final-cutover'
           ], 
           description: 'Migration execution mode: plan-only (generate files), test-migration (dry-run), safe-migration (inactive jobs), final-cutover (all jobs)')
    booleanParam(name: 'DRY_RUN', description: 'Perform rsync with --dry-run')
    booleanParam(name: 'EXCLUDE_BUILD_HISTORY', defaultValue: true, description: 'Exclude build history and console logs from migration')
    booleanParam(name: 'AUTO_CREATE_PR', description: 'Automatically create a GitHub pull request after Git push')
    booleanParam(name: 'EXCLUDE_RBAC', defaultValue: false, description: 'Exclude folder and job RBAC permissions from migration')
    string(name: 'MAX_FAILURES', defaultValue: '10', description: 'Max allowed failures before abort')
}  

    environment {
        ASSIGNMENTS_FILE = "assignments.csv"
        FAILURE_COUNT = 0
    }

    stages {
        stage('Validate Parameters') {
            steps {
                script {
                    def errors = []
                    
                    // Required string parameters
                    if (!params.SOURCE_CONFIG || params.SOURCE_CONFIG.trim().isEmpty()) {
                        errors << "SOURCE_CONFIG is required"
                    }

                    if (params.SOURCE_CONFIG) {
                        if (!fileExists("${params.SOURCE_CONFIG}/")) {
                            errors << "SOURCE_CONFIG folder '${params.SOURCE_CONFIG}' does not exist in repository. Create the folder first to confirm intentional migration."
                        }
                    }
                    
                    if (!params.CB_HOME || params.CB_HOME.trim().isEmpty()) {
                        errors << "CB_HOME is required"
                    }
                    
                    if (!params.SSH_CREDENTIAL_ID || params.SSH_CREDENTIAL_ID.trim().isEmpty()) {
                        errors << "SSH_CREDENTIAL_ID is required"
                    }
                    
                    if (!params.MULTI_TARGETS || params.MULTI_TARGETS.trim().isEmpty()) {
                        errors << "MULTI_TARGETS is required"
                    }
                    
                    if (!params.MAX_FAILURES || params.MAX_FAILURES.trim().isEmpty()) {
                        errors << "MAX_FAILURES is required"
                    }
                    
                    // Validate MODE values
                    def validModes = ['plan-only', 'test-migration', 'safe-migration', 'final-cutover']
                    if (params.MODE && !validModes.contains(params.MODE)) {
                        errors << "MODE must be one of: ${validModes.join(', ')}"
                    }
                    
                    // Validate MULTI_TARGETS format
                    if (params.MULTI_TARGETS) {
                        try {
                            def targets = params.MULTI_TARGETS.split(',')
                            targets.each { target ->
                                if (!target.contains(':')) {
                                    errors << "MULTI_TARGETS format error: '${target}' must be 'name:ip'"
                                }
                            }
                        } catch (Exception e) {
                            errors << "MULTI_TARGETS format error: ${e.message}"
                        }
                    }
                    
                    // Validate MAX_FAILURES is numeric
                    if (params.MAX_FAILURES) {
                        try {
                            Integer.parseInt(params.MAX_FAILURES)
                        } catch (NumberFormatException e) {
                            errors << "MAX_FAILURES must be a number"
                        }
                    }
                    
                    // Validate CB_HOME path format
                    if (params.CB_HOME && !params.CB_HOME.startsWith('/')) {
                        errors << "CB_HOME must be an absolute path starting with '/'"
                    }
                    
                    // Display all parameter values for verification
                    echo "=== PARAMETER VALIDATION ==="
                    echo "SOURCE_CONFIG: '${params.SOURCE_CONFIG}'"
                    echo "CB_HOME: '${params.CB_HOME}'"
                    echo "SSH_CREDENTIAL_ID: '${params.SSH_CREDENTIAL_ID}'"
                    echo "MULTI_TARGETS: '${params.MULTI_TARGETS}'"
                    echo "MODE: '${params.MODE}'"
                    echo "DRY_RUN: ${params.DRY_RUN}"
                    echo "EXCLUDE_BUILD_HISTORY: ${params.EXCLUDE_BUILD_HISTORY}"
                    echo "AUTO_CREATE_PR: ${params.AUTO_CREATE_PR}"
                    echo "MAX_FAILURES: '${params.MAX_FAILURES}'"
                    echo "EXCLUDE_RBAC: ${params.EXCLUDE_RBAC}"
                    echo "=========================="
                    
                    // Fail if any validation errors
                    if (errors.size() > 0) {
                        echo "VALIDATION FAILED:"
                        errors.each { error ->
                            echo "  ❌ ${error}"
                        }
                        error("Parameter validation failed. Please correct the above errors and try again.")
                    } else {
                        echo "All parameters validated successfully"
                    }
                }
            }
        }
        stage('Validate Target Controller Connectivity') {
            steps {
                script {
                    def controllers = params.MULTI_TARGETS.split(',').collect { it.split(':')[1].trim() }

                    controllers.each { controllerIp ->
                        echo "Testing SSH connection to ${controllerIp}"

                        withCredentials([sshUserPrivateKey(credentialsId: "${params.SSH_CREDENTIAL_ID}", keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')]) {
                            sh "ssh -i \$SSH_KEY -o StrictHostKeyChecking=no \$SSH_USER@${controllerIp} 'echo Connected to \$(hostname)'"
                            sh "ssh -i \$SSH_KEY -o StrictHostKeyChecking=no \$SSH_USER@${controllerIp} 'echo JENKINS_HOME=\$JENKINS_HOME'"
                        }

                        echo "SSH test to ${controllerIp} completed successfully"
                    }
                }
            }
        }

        stage('Pre-Migration Verification') {
            when {
                expression { return params.MODE == 'final-cutover' }
            }
            steps {
                script {
                    echo "=========================================="
                    echo "PRE-MIGRATION CHECKLIST VERIFICATION"
                    echo "=========================================="
                    echo "This is a FINAL MIGRATION (final-cutover mode)"
                    echo "Critical manual steps must be completed:"
                    echo ""
                    echo "1. Source controller MUST be in Quiet Down mode"
                    echo "2. Target controllers MUST be in Quiet Down mode" 
                    echo "3. Source controller backup verified"
                    echo "4. All teams notified of migration window"
                    echo "5. Maintenance window confirmed and active"
                    echo "=========================================="
                    
                    input message: """
        FINAL MIGRATION - Manual verification required:

        ✓ Source controller in Quiet Down mode (REQUIRED)
        ✓ Target controllers in Quiet Down mode  
        ✓ Source controller backup completed and verified
        ✓ Development teams notified of migration window
        ✓ Maintenance window confirmed and active

        Confirm all manual prerequisites are complete before proceeding with final sync.

        Click 'All Prerequisites Complete' to proceed or 'Abort' to cancel.
        """,
                    ok: 'All Prerequisites Complete - Proceed',
                    submitterParameter: 'MIGRATION_APPROVER'
                    
                    echo "Final migration prerequisites verified by: ${env.MIGRATION_APPROVER}"
                    echo "Proceeding with final cutover migration..."
                }
            }
        }

        stage('Generate Migration Plan Files') {
            steps {
                script {
                    echo "Generating migration plan using shared library..."

                    def migrationResults = generateMigrationFiles([
                        parentFolderPath: "",
                        migrationDepth: 0,
                        activityThresholdDays: 180,
                        targetControllers: params.MULTI_TARGETS.split(',').collect { it.split(':')[0].trim() },
                        outputDir: "${params.SOURCE_CONFIG}",
                        verbose: true,
                        dryRun: params.MODE == 'plan-only',
                        excludeBuildHistory: params.EXCLUDE_BUILD_HISTORY,  // New parameter
                        excludeRbac: params.EXCLUDE_RBAC,                   // New parameter
                        excludePatterns: []
                    ])

                    echo "Migration Plan Generated:"
                    echo " - Jobs Analyzed: ${migrationResults.stats.totalJobs}"
                    echo " - Assignments: ${migrationResults.assignments.size()}"
                    echo " - Output Directory: ${params.SOURCE_CONFIG}"
                    echo "Generated per-controller rsync input files:"
                    def controllerKeys = migrationResults.assignments.collect { it.split(',')[1].trim() }.toSet().sort()
                    controllerKeys.each { name ->
                        echo " - ${params.SOURCE_CONFIG}/${name}.txt"
                    }

                    if (params.PLAN_DRY_RUN) {
                        echo "[PLAN_DRY_RUN] Skipping Git operations."
                        sh """
                            echo 'Preview of assignments.csv:'
                            head -n 10 ${params.SOURCE_CONFIG}/assignments.csv || echo 'No file found'
                        """
                    }
                }
            }
        }

        stage('Commit and Push Migration Plan') {
            when {
                expression { return params.MODE != 'plan-only' }
            }
            steps {
                script {
                    def timestamp = new Date().format('yyyyMMdd-HHmmss')
                    def branchName = "${params.SOURCE_CONFIG}-${timestamp}"
                    env.MIGRATION_BRANCH = branchName
                    echo "Creating new branch '${branchName}' and pushing migration files..."
                }
                
                sh "git config user.email 'jenkins@migration.mail'"
                sh "git config user.name 'Jenkins Migration Pipeline'"
                sh "git checkout -b \${MIGRATION_BRANCH}"
                sh "git add ${params.SOURCE_CONFIG}/"
                
                script {
                    // Check if there are actually changes to commit
                    def gitStatus = sh(script: "git status --porcelain", returnStdout: true).trim()
                    
                    if (gitStatus.isEmpty()) {
                        echo "=========================================="
                        echo "NO CHANGES DETECTED"
                        echo "=========================================="
                        echo "The migration files are identical to existing ones."
                        echo "This typically means:"
                        echo "- No new jobs have been added"
                        echo "- No job activity status has changed" 
                        echo "- No migration parameters have changed"
                        echo "Proceeding with migration using existing files..."
                        echo "=========================================="
                    } else {
                        sh "git commit -m 'Migration plan for ${params.SOURCE_CONFIG} - \${BUILD_TIMESTAMP}'"
                        sh "git push origin \${MIGRATION_BRANCH}"
                        
                        def commitHash = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
                        env.COMMIT_HASH = commitHash
                        
                        echo "====== MIGRATION PLAN PUSHED ======"
                        echo "Branch: ${env.MIGRATION_BRANCH}"
                        echo "Commit Hash: ${commitHash}"
                        echo "Repository: ${env.GIT_URL ?: env.GIT_URL_1}"
                        echo "Files pushed to: ${params.SOURCE_CONFIG}/"
                        echo "====================================="
                    }
                }
            }
        }

        stage('Manual PR Review and Approval') {
            when {
                expression { return params.MODE != 'plan-only' }
            }
            steps {
                timeout(time: 60, unit: 'MINUTES') {
                    script {
                        def branchName = env.MIGRATION_BRANCH
                        def commitHash = env.COMMIT_HASH
                        def gitUrl = env.GIT_URL ?: env.GIT_URL_1
                        
                        // Simple string-based repo extraction
                        def repoId = "unknown/repo"
                        try {
                            if (gitUrl && gitUrl.contains("github.com")) {
                                def cleanUrl = gitUrl.replace("git@github.com:", "").replace("https://github.com/", "").replace(".git", "")
                                if (cleanUrl.contains("/")) {
                                    repoId = cleanUrl
                                }
                            }
                        } catch (Exception e) {
                            repoId = "check-git-repo-manually"
                        }
                        
                        def prUrl = "https://github.com/${repoId}/compare/main...${branchName}"

                        echo "=========================================="
                        echo "MANUAL REVIEW REQUIRED"
                        echo "=========================================="
                        echo "Branch: ${branchName}"
                        echo "Commit: ${commitHash}"
                        echo "Create PR at: ${prUrl}"
                        echo ""
                        echo "Migration files generated:"
                        echo "- ${params.SOURCE_CONFIG}/active.txt"
                        echo "- ${params.SOURCE_CONFIG}/inactive.txt" 
                        echo "- ${params.SOURCE_CONFIG}/combined.txt"
                        echo "- ${params.SOURCE_CONFIG}/assignments.csv"
                        echo "- ${params.SOURCE_CONFIG}/excludes.txt"
                        echo "- Controller-specific rsync files:"
                        controllerKeys.each { name ->
                            echo "   - ${params.SOURCE_CONFIG}/${name}.txt"
                        }
                        echo ""

                        echo "Next Steps:"
                        echo "1. Review the pushed migration files in the branch"
                        echo "2. Create a Pull Request using the URL above"
                        echo "3. Have team review and merge the PR"
                        echo "4. Click 'Merge Complete' to continue or 'Abort' to stop"
                        echo "=========================================="

                        input message: """
        Migration plan pushed to branch: ${branchName}

        Create PR at: ${prUrl}

        After reviewing and merging the PR, click 'Merge Complete' to continue with migration execution.

        Click 'Abort' if you need to stop the process to resolve issues.
        """, 
                        ok: 'Merge Complete - Continue Migration',
                        submitterParameter: 'APPROVER'
                        
                        echo "Migration approved by: ${env.APPROVER}"
                        echo "Proceeding with migration execution..."
                    }
                }
            }
        }

        stage('Execute Migration') {
            when {
                expression { return params.MODE != 'plan-only' }
            }
            steps {
                script {
                    def targets = params.MULTI_TARGETS.split(',').collectEntries {
                        def (name, ip) = it.trim().split(':')
                        [(name): ip]
                    }
        
                    targets.each { controller, ip ->
                        def folderListFile = "${params.SOURCE_CONFIG}/${controller}.txt"
        
                        if (!fileExists(folderListFile)) {
                            echo "${controller}.txt not found — skipping controller '${controller}'."
                            return
                        }
        
                        echo "Processing folders assigned to: ${controller} (${ip})"
                        def folders = readFile(folderListFile).split('\n').findAll { it.trim() }
        
                        folders.each { folder ->
                            def sourcePath = "${params.CB_HOME}/jobs/${folder}"
                            def targetPath = "${params.CB_HOME}/jobs/${folder}"
        
                            def rsyncCmd = "rsync -az --delete ${sourcePath}/ ${controller}:${targetPath}/"
        
                            switch (params.MODE) {
                                case 'test-migration':
                                    rsyncCmd += " --dry-run --stats"
                                    break
                                case 'safe-migration':
                                case 'final-cutover':
                                    // No extra flags — real copy
                                    break
                            }
        
                            if (params.EXCLUDE_BUILD_HISTORY) {
                                rsyncCmd += " --exclude='**/builds/*/log' --exclude='**/*.log'"
                            }
        
                            if (params.EXCLUDE_RBAC) {
                                rsyncCmd += " --exclude='**/nectar-rbac.xml'"
                            }
        
                            echo "[SIMULATION] Would run rsync for job folder:"
                            echo "  Controller : ${controller}"
                            echo "  Folder path: ${folder}"
                            echo "  Rsync cmd  : ${rsyncCmd}"
        
                            // Uncomment below to trigger real rsync
                            // sh rsyncCmd
                        }
                    }
                }
            }
        }

    stage('Migration Summary and Status') {
        steps {
            script {
                def assignmentFile = "${params.SOURCE_CONFIG}/${env.ASSIGNMENTS_FILE}"
                def assignmentCount = 0
                def controllerTargets = []
    
                if (fileExists(assignmentFile)) {
                    def raw = readFile(assignmentFile).split('\n')
                    def assignments = raw.size() > 1 
                        ? raw[1..-1].findAll { it.trim() }.collect { it.split(',') }
                        : []
                    assignmentCount = assignments.size()
                    controllerTargets = assignments.collect { it[1].trim() }.unique().sort()
                }
    
                echo "========== MIGRATION SUMMARY =========="
                echo "Mode: ${params.MODE}"
                echo "Plan Only: ${params.MODE == 'plan-only'}"
                echo "DRY_RUN: ${params.DRY_RUN}"
                echo "RBAC Excluded: ${params.EXCLUDE_RBAC}"
                echo "Total Assignments: ${assignmentCount}"
                echo "Target Controllers from assignments.csv:"
                controllerTargets.each { echo "  - ${it}" }
    
                echo ""
                controllerTargets.each { controller ->
                    def filePath = "${params.SOURCE_CONFIG}/${controller}.txt"
                    if (fileExists(filePath)) {
                        def lines = readFile(filePath).split('\n').findAll { it.trim() }.size()
                        echo "  → ${controller}.txt: ${lines} folder(s)"
                    } else {
                        echo "  ✘ ${controller}.txt not found"
                    }
                }
                echo "======================================="
            }
        }
    }
    
    post {
        always {
            // Archive per-controller TXT input files for rsync
            archiveArtifacts artifacts: "${params.SOURCE_CONFIG}/*.txt", allowEmptyArchive: true
            cleanWs()
        }
        success {
            echo "[DONE] Migration pipeline completed successfully."
        }
        failure {
            echo "[ERROR] Migration failed. Check logs for details."
        }
    }
}
