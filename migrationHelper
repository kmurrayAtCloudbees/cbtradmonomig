pipeline {
    agent {
        label 'cb-migration'
    }

    parameters {
        string(name: 'SOURCE_CONFIG', defaultValue: 'source-controller-vcps-monolith', description: 'Folder in Git containing includes and assignments')
        string(name: 'CB_HOME', defaultValue: '/vcps_jenkins/jenkins_homes/vcps-monolith', description: 'Path to JENKINS_HOME on source')
        string(name: 'SSH_CREDENTIAL_ID', defaultValue: 'controllerssh', description: 'Credential ID for SSH private key')
        string(name: 'MULTI_TARGETS', defaultValue: 'controllerSource:192.168.4.241,controllerTarget:192.168.4.242', description: 'Comma-separated list of controller:IP pairs')
        booleanParam(name: 'PLAN_DRY_RUN', defaultValue: true, description: 'Plan only: generate includes/assignments, skip Git push/PR')
        booleanParam(name: 'DRY_RUN', defaultValue: true, description: 'Perform rsync with --dry-run')
        booleanParam(name: 'INCLUDE_BUILD_LOGS', defaultValue: true, description: 'Include build logs during rsync')
        booleanParam(name: 'RELOAD_TARGET', defaultValue: false, description: 'Reload target Jenkins instance after sync')
        booleanParam(name: 'DISABLE_SOURCE_JOBS_AFTER_MIGRATION', defaultValue: false, description: 'Disable source jobs after migration')
        booleanParam(name: 'QUIET_DOWN_SOURCE', defaultValue: false, description: 'Put source controller into Quiet Down before final sync')
        booleanParam(name: 'AUTO_CREATE_PR', defaultValue: false, description: 'Auto-create GitHub Pull Request after pushing migration plan')
        string(name: 'MODE', defaultValue: 'dry-run', description: 'dry-run | inactive | delta')
        string(name: 'MAX_FAILURES', defaultValue: '10', description: 'Max allowed failures before abort')
    }

    environment {
        ASSIGNMENTS_FILE = "assignments.csv"
        FAILURE_COUNT = 0
    }

    stages {

        stage('Validate Target Controller Connectivity') {
            steps {
                script {
                    def controllers = params.MULTI_TARGETS.split(',').collect { it.split(':')[1].trim() }

                    controllers.each { controllerIp ->
                        echo "Testing SSH connection to ${controllerIp}"

                        withCredentials([sshUserPrivateKey(credentialsId: "${params.SSH_CREDENTIAL_ID}", keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')]) {
                            sh "ssh -i \$SSH_KEY -o StrictHostKeyChecking=no \$SSH_USER@${controllerIp} 'echo \"Connected to \$(hostname)\"'"
                            sh "ssh -i \$SSH_KEY -o StrictHostKeyChecking=no \$SSH_USER@${controllerIp} 'ls -la /var/lib/jenkins || ls -la /var/lib/cloudbees-*'"
                            sh "ssh -i \$SSH_KEY -o StrictHostKeyChecking=no \$SSH_USER@${controllerIp} 'echo \"Test from pipeline at \$(date)\" > /tmp/migration-test.txt'"
                            sh "ssh -i \$SSH_KEY -o StrictHostKeyChecking=no \$SSH_USER@${controllerIp} 'cat /tmp/migration-test.txt'"
                        }

                        echo "SSH test to ${controllerIp} completed successfully"
                    }
                }
            }
        }

        stage('Generate Migration Plan Files') {
            steps {
                script {
                    echo "Generating migration plan using shared library..."

                    def migrationResults = generateMigrationFiles([
                        parentFolderPath: "", // Optional: could be a parameter
                        migrationDepth: 0,
                        activityThresholdDays: 180,
                        targetControllers: params.MULTI_TARGETS.split(',').collect { it.split(':')[0].trim() },
                        outputDir: "${params.SOURCE_CONFIG}",
                        verbose: true,
                        dryRun: false,
                        excludePatterns: ['**/test-*', '**/sandbox/*']
                    ])

                    echo "Migration Plan Generated:"
                    echo " - Jobs Analyzed: ${migrationResults.stats.totalJobs}"
                    echo " - Assignments: ${migrationResults.assignments.size()}"
                    echo " - Output Directory: ${params.SOURCE_CONFIG}"

                    if (params.PLAN_DRY_RUN) {
                        echo "[PLAN_DRY_RUN] Skipping Git commit/push and PR creation."

                        // Optional file preview
                        sh """
                            echo 'Preview of assignments.csv:'
                            head -n 10 ${params.SOURCE_CONFIG}/assignments.csv || echo 'No file found'
                        """
                    } else {
                        echo "[LIVE PLAN] Committing and pushing migration plan..."
                        def sourceController = 'controllerSource'
                        def timestamp = new Date().format('yyyyMMdd-HHmmss')
                        def branchName = "${sourceController}-${timestamp}"

                        sh "git config user.email 'jenkins@migration.test'"
                        sh "git config user.name 'Jenkins Migration Pipeline'"
                        sh "git checkout -b ${branchName}"
                        sh "git add ${params.SOURCE_CONFIG}/"
                        sh "git commit -m 'Migration plan for ${sourceController} - ${timestamp}'"
                        sh "git push origin ${branchName}"

                        echo "Files pushed to branch '${branchName}'"

                        if (params.AUTO_CREATE_PR) {
                            echo "(Stub) This is where PR creation will be added in next step"
                            // Future integration of gh pr create or GitHub API call
                        }
                    }
                }
            }
        }

        stage('Execute Migration') {
            when {
                expression { return params.PLAN_DRY_RUN == false }
            }
            steps {
                script {
                    def includes = ['vcbd/dmpd/ccrtpvweb/qa', 'vcbd/dmpd/ccrtpvweb/production'] // TODO: parse from includes.txt

                    def targets = params.MULTI_TARGETS.split(',').collectEntries {
                        def (name, ip) = it.split(':')
                        [(name.trim()): ip.trim()]
                    }

                    targets.each { controller, ip ->
                        echo "== Executing rsync to ${controller} @ ${ip} =="

                        includes.each { folder ->
                            def sourcePath = "${params.CB_HOME}/jobs/${folder}"
                            def targetPath = "${params.CB_HOME}/jobs/${folder}"

                            def rsyncCommand = "rsync -az --delete ${sourcePath}/ ${controller}:${targetPath}/"
                            if (params.DRY_RUN) {
                                rsyncCommand += " --dry-run --stats"
                            }

                            if (!params.INCLUDE_BUILD_LOGS) {
                                rsyncCommand += " --exclude='**/builds/*/log' --exclude='**/*.log'"
                            }

                            echo "Rsync command prepared:"
                            echo "${rsyncCommand}"

                            // (Optional: Uncomment to run)
                            // sh rsyncCommand

                            if (params.RELOAD_TARGET) {
                                echo "[TODO] Reload configuration on target: ${controller}"
                            }

                            if (params.DISABLE_SOURCE_JOBS_AFTER_MIGRATION) {
                                echo "[TODO] Disable source jobs under: ${folder}"
                            }
                        }
                    }
                }
            }
        }

        stage('Migration Summary and Status') {
            steps {
                echo "[SUMMARY] Mode: ${params.MODE}"
                echo "[SUMMARY] DRY_RUN: ${params.DRY_RUN}"
                echo "[SUMMARY] Plan Only: ${params.PLAN_DRY_RUN}"
                echo "[SUMMARY] Job folders processed: MOCKED/FIXME"
                echo "[SUMMARY] Failures: ${env.FAILURE_COUNT}"
            }
        }
    }

    post {
        success {
            echo "[DONE] Migration pipeline completed successfully."
        }
        failure {
            echo "[ERROR] Migration failed. Check logs for details."
        }
    }
}