pipeline {
    agent {
        label 'cb-migration'
    }

parameters {
    string(name: 'SOURCE_CONFIG', description: 'Folder name representing the source controller (used for file structure and branch naming)')
    string(name: 'CB_HOME', description: 'Path to JENKINS_HOME on source')
    string(name: 'SSH_CREDENTIAL_ID', description: 'Credential ID for SSH private key')
    string(name: 'MULTI_TARGETS', description: 'Comma-separated list of controller:IP pairs')
    choice(name: 'MODE', 
           choices: [
               'plan-only', 
               'test-migration', 
               'safe-migration', 
               'final-cutover'
           ], 
           description: 'Migration execution mode: plan-only (generate files), test-migration (dry-run), safe-migration (inactive jobs), final-cutover (all jobs)')
    booleanParam(name: 'DRY_RUN', description: 'Perform rsync with --dry-run')
    booleanParam(name: 'INCLUDE_BUILD_LOGS', description: 'Include build logs during rsync')
    booleanParam(name: 'RELOAD_TARGET', description: 'Reload target Jenkins instance after sync')
    booleanParam(name: 'DISABLE_SOURCE_JOBS_AFTER_MIGRATION', description: 'Disable source jobs after migration')
    booleanParam(name: 'QUIET_DOWN_SOURCE', description: 'Put source controller into Quiet Down before final sync (Required for final migration)')
    booleanParam(name: 'AUTO_CREATE_PR', description: 'Automatically create a GitHub pull request after Git push')
    string(name: 'MAX_FAILURES', description: 'Max allowed failures before abort')
}  

    environment {
        ASSIGNMENTS_FILE = "assignments.csv"
        FAILURE_COUNT = 0
    }

    stages {
        stage('Validate Parameters') {
            steps {
                script {
                    def errors = []
                    
                    // Required string parameters
                    if (!params.SOURCE_CONFIG || params.SOURCE_CONFIG.trim().isEmpty()) {
                        errors << "SOURCE_CONFIG is required"
                    }

                    if (params.SOURCE_CONFIG) {
                        if (!fileExists("${params.SOURCE_CONFIG}/")) {
                            errors << "SOURCE_CONFIG folder '${params.SOURCE_CONFIG}' does not exist in repository. Create the folder first to confirm intentional migration."
                        }
                    }
                    
                    if (!params.CB_HOME || params.CB_HOME.trim().isEmpty()) {
                        errors << "CB_HOME is required"
                    }
                    
                    if (!params.SSH_CREDENTIAL_ID || params.SSH_CREDENTIAL_ID.trim().isEmpty()) {
                        errors << "SSH_CREDENTIAL_ID is required"
                    }
                    
                    if (!params.MULTI_TARGETS || params.MULTI_TARGETS.trim().isEmpty()) {
                        errors << "MULTI_TARGETS is required"
                    }
                    
                    if (!params.MAX_FAILURES || params.MAX_FAILURES.trim().isEmpty()) {
                        errors << "MAX_FAILURES is required"
                    }
                    
                    // Validate MODE values
                    def validModes = ['plan-only', 'test-migration', 'safe-migration', 'final-cutover']
                    if (params.MODE && !validModes.contains(params.MODE)) {
                        errors << "MODE must be one of: ${validModes.join(', ')}"
                    }
                    
                    // Validate MULTI_TARGETS format
                    if (params.MULTI_TARGETS) {
                        try {
                            def targets = params.MULTI_TARGETS.split(',')
                            targets.each { target ->
                                if (!target.contains(':')) {
                                    errors << "MULTI_TARGETS format error: '${target}' must be 'name:ip'"
                                }
                            }
                        } catch (Exception e) {
                            errors << "MULTI_TARGETS format error: ${e.message}"
                        }
                    }
                    
                    // Validate MAX_FAILURES is numeric
                    if (params.MAX_FAILURES) {
                        try {
                            Integer.parseInt(params.MAX_FAILURES)
                        } catch (NumberFormatException e) {
                            errors << "MAX_FAILURES must be a number"
                        }
                    }
                    
                    // Validate CB_HOME path format
                    if (params.CB_HOME && !params.CB_HOME.startsWith('/')) {
                        errors << "CB_HOME must be an absolute path starting with '/'"
                    }
                    
                    // Display all parameter values for verification
                    echo "=== PARAMETER VALIDATION ==="
                    echo "SOURCE_CONFIG: '${params.SOURCE_CONFIG}'"
                    echo "CB_HOME: '${params.CB_HOME}'"
                    echo "SSH_CREDENTIAL_ID: '${params.SSH_CREDENTIAL_ID}'"
                    echo "MULTI_TARGETS: '${params.MULTI_TARGETS}'"
                    echo "MODE: '${params.MODE}'"
                    echo "DRY_RUN: ${params.DRY_RUN}"
                    echo "INCLUDE_BUILD_LOGS: ${params.INCLUDE_BUILD_LOGS}"
                    echo "RELOAD_TARGET: ${params.RELOAD_TARGET}"
                    echo "DISABLE_SOURCE_JOBS_AFTER_MIGRATION: ${params.DISABLE_SOURCE_JOBS_AFTER_MIGRATION}"
                    echo "QUIET_DOWN_SOURCE: ${params.QUIET_DOWN_SOURCE}"
                    echo "AUTO_CREATE_PR: ${params.AUTO_CREATE_PR}"
                    echo "MAX_FAILURES: '${params.MAX_FAILURES}'"
                    echo "=========================="
                    
                    // Fail if any validation errors
                    if (errors.size() > 0) {
                        echo "VALIDATION FAILED:"
                        errors.each { error ->
                            echo "  ❌ ${error}"
                        }
                        error("Parameter validation failed. Please correct the above errors and try again.")
                    } else {
                        echo "All parameters validated successfully"
                    }
                }
            }
        }
        stage('Validate Target Controller Connectivity') {
            steps {
                script {
                    def controllers = params.MULTI_TARGETS.split(',').collect { it.split(':')[1].trim() }

                    controllers.each { controllerIp ->
                        echo "Testing SSH connection to ${controllerIp}"

                        withCredentials([sshUserPrivateKey(credentialsId: "${params.SSH_CREDENTIAL_ID}", keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')]) {
                            sh "ssh -i \$SSH_KEY -o StrictHostKeyChecking=no \$SSH_USER@${controllerIp} 'echo Connected to \$(hostname)'"
                            sh "ssh -i \$SSH_KEY -o StrictHostKeyChecking=no \$SSH_USER@${controllerIp} 'echo JENKINS_HOME=\$JENKINS_HOME'"
                        }

                        echo "SSH test to ${controllerIp} completed successfully"
                    }
                }
            }
        }

        stage('Generate Migration Plan Files') {
            steps {
                script {
                    echo "Generating migration plan using shared library..."

                    def migrationResults = generateMigrationFiles([
                        parentFolderPath: "",
                        migrationDepth: 0,
                        activityThresholdDays: 180,
                        targetControllers: params.MULTI_TARGETS.split(',').collect { it.split(':')[0].trim() },
                        outputDir: "${params.SOURCE_CONFIG}",
                        verbose: true,
                        dryRun: params.MODE == 'plan-only',  // Only dry run for plan-only mode
                        excludePatterns: ['**/test-*', '**/sandbox/*']
                    ])

                    echo "Migration Plan Generated:"
                    echo " - Jobs Analyzed: ${migrationResults.stats.totalJobs}"
                    echo " - Assignments: ${migrationResults.assignments.size()}"
                    echo " - Output Directory: ${params.SOURCE_CONFIG}"

                    if (params.PLAN_DRY_RUN) {
                        echo "[PLAN_DRY_RUN] Skipping Git operations."
                        sh """
                            echo 'Preview of assignments.csv:'
                            head -n 10 ${params.SOURCE_CONFIG}/assignments.csv || echo 'No file found'
                        """
                    }
                }
            }
        }

        stage('Commit and Push Migration Plan') {
            when {
                expression { return params.MODE != 'plan-only' }
            }
            steps {
                script {
                    def timestamp = new Date().format('yyyyMMdd-HHmmss')
                    def branchName = "${params.SOURCE_CONFIG}-${timestamp}"
                    env.MIGRATION_BRANCH = branchName
                    echo "Creating new branch '${branchName}' and pushing migration files..."
                }
                
                sh "git config user.email 'jenkins@migration.mail'"
                sh "git config user.name 'Jenkins Migration Pipeline'"
                sh "git checkout -b \${MIGRATION_BRANCH}"
                sh "git add ${params.SOURCE_CONFIG}/"
                
                script {
                    // Check if there are actually changes to commit
                    def gitStatus = sh(script: "git status --porcelain", returnStdout: true).trim()
                    
                    if (gitStatus.isEmpty()) {
                        echo "=========================================="
                        echo "NO CHANGES DETECTED"
                        echo "=========================================="
                        echo "The migration files are identical to existing ones."
                        echo "This typically means:"
                        echo "- No new jobs have been added"
                        echo "- No job activity status has changed" 
                        echo "- No migration parameters have changed"
                        echo "Proceeding with migration using existing files..."
                        echo "=========================================="
                    } else {
                        sh "git commit -m 'Migration plan for ${params.SOURCE_CONFIG} - \${BUILD_TIMESTAMP}'"
                        sh "git push origin \${MIGRATION_BRANCH}"
                        
                        def commitHash = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
                        env.COMMIT_HASH = commitHash
                        
                        echo "====== MIGRATION PLAN PUSHED ======"
                        echo "Branch: ${env.MIGRATION_BRANCH}"
                        echo "Commit Hash: ${commitHash}"
                        echo "Repository: ${env.GIT_URL ?: env.GIT_URL_1}"
                        echo "Files pushed to: ${params.SOURCE_CONFIG}/"
                        echo "====================================="
                    }
                }
            }
        }

        stage('Manual PR Review and Approval') {
            when {
                expression { return params.MODE != 'plan-only' }
            }
            steps {
                timeout(time: 60, unit: 'MINUTES') {
                    script {
                        def branchName = env.MIGRATION_BRANCH
                        def commitHash = env.COMMIT_HASH
                        def gitUrl = env.GIT_URL ?: env.GIT_URL_1
                        
                        // Simple string-based repo extraction
                        def repoId = "unknown/repo"
                        try {
                            if (gitUrl && gitUrl.contains("github.com")) {
                                def cleanUrl = gitUrl.replace("git@github.com:", "").replace("https://github.com/", "").replace(".git", "")
                                if (cleanUrl.contains("/")) {
                                    repoId = cleanUrl
                                }
                            }
                        } catch (Exception e) {
                            repoId = "check-git-repo-manually"
                        }
                        
                        def prUrl = "https://github.com/${repoId}/compare/main...${branchName}"

                        echo "=========================================="
                        echo "MANUAL REVIEW REQUIRED"
                        echo "=========================================="
                        echo "Branch: ${branchName}"
                        echo "Commit: ${commitHash}"
                        echo "Create PR at: ${prUrl}"
                        echo ""
                        echo "Migration files generated:"
                        echo "- ${params.SOURCE_CONFIG}/active.txt"
                        echo "- ${params.SOURCE_CONFIG}/inactive.txt" 
                        echo "- ${params.SOURCE_CONFIG}/combined.txt"
                        echo "- ${params.SOURCE_CONFIG}/assignments.csv"
                        echo "- ${params.SOURCE_CONFIG}/excludes.txt"
                        echo ""
                        echo "Next Steps:"
                        echo "1. Review the pushed migration files in the branch"
                        echo "2. Create a Pull Request using the URL above"
                        echo "3. Have team review and merge the PR"
                        echo "4. Click 'Merge Complete' to continue or 'Abort' to stop"
                        echo "=========================================="

                        input message: """
        Migration plan pushed to branch: ${branchName}

        Create PR at: ${prUrl}

        After reviewing and merging the PR, click 'Merge Complete' to continue with migration execution.

        Click 'Abort' if you need to stop the process to resolve issues.
        """, 
                        ok: 'Merge Complete - Continue Migration',
                        submitterParameter: 'APPROVER'
                        
                        echo "Migration approved by: ${env.APPROVER}"
                        echo "Proceeding with migration execution..."
                    }
                }
            }
        }

        stage('Execute Migration') {
            when {
                expression { return params.MODE != 'plan-only' }
            }
            steps {
                script {
                    def assignmentFile = "${params.SOURCE_CONFIG}/${env.ASSIGNMENTS_FILE}"
                    
                    if (fileExists(assignmentFile)) {
                        def csvContent = readFile(assignmentFile)
                        def raw = csvContent.split('\n')
                        echo "Loaded ${raw.size()} lines from ${assignmentFile}"
                        
                        def assignments = []
                        if (raw.size() > 1) {
                            echo "=== CSV PARSING DEBUG ==="
                            raw.eachWithIndex { line, index ->
                                echo "Line ${index}: '${line}'"
                            }
                            
                            assignments = raw[1..-1].findAll { it.trim() && !it.trim().isEmpty() }.collect { line ->
                                def parts = line.split(',').collect { it.trim() }
                                echo "Parsed line: ${parts}"
                                return parts
                            }
                            
                            echo "Final assignments: ${assignments}"
                            echo "========================"
                        } else {
                            error "assignments.csv appears to be empty or missing header"
                        }

                        def targets = params.MULTI_TARGETS.split(',').collectEntries {
                            def (name, ip) = it.trim().split(':')
                            [(name): ip]
                        }

                        assignments.each { row ->
                            def jobPath = row[0].trim()
                            def targetController = row[1].trim()

                            if (!targets.containsKey(targetController)) {
                                error "Controller '${targetController}' in assignments.csv is not listed in MULTI_TARGETS"
                            }

                            def controllerIp = targets[targetController]
                            def sourcePath = "${params.CB_HOME}/jobs/${jobPath}"
                            def targetPath = "${params.CB_HOME}/jobs/${jobPath}"

                            def rsyncCmd = "rsync -az --delete ${sourcePath}/ ${targetController}:${targetPath}/"

                            if (params.DRY_RUN) {
                                rsyncCmd += " --dry-run --stats"
                            }

                            if (!params.INCLUDE_BUILD_LOGS) {
                                rsyncCmd += " --exclude='**/builds/*/log' --exclude='**/*.log'"
                            }

                            echo "[SIMULATION] Would run rsync for job folder:"
                            echo "  Source path: ${sourcePath}"
                            echo "  Target     : ${targetController} => ${controllerIp}"
                            echo "  Rsync cmd  : ${rsyncCmd}"
                            
                            // Simulated rsync — real command is disabled
                            // sh rsyncCmd

                            if (params.RELOAD_TARGET) {
                                echo "[SIMULATION] Would reload Jenkins on target controller ${targetController}"
                            }

                            if (params.DISABLE_SOURCE_JOBS_AFTER_MIGRATION) {
                                echo "[SIMULATION] Would disable source job: ${jobPath}"
                            }
                        }
                    } else {
                        error "assignments.csv not found at ${assignmentFile}"
                    }
                }
            }
        }

        stage('Migration Summary and Status') {
            steps {
                script {
                    def assignmentFile = "${params.SOURCE_CONFIG}/${env.ASSIGNMENTS_FILE}"
                    def assignmentCount = 0
                    def controllerTargets = []

                    if (fileExists(assignmentFile)) {
                        def raw = readFile(assignmentFile).split('\n')
                        def assignments = raw.size() > 1 
                            ? raw[1..-1].findAll { it.trim() }.collect { it.split(',') }
                            : []
                        assignmentCount = assignments.size()
                        controllerTargets = assignments.collect { it[1].trim() }.unique().sort()
                    }

                    echo "[SUMMARY] Mode: ${params.MODE}"
                    echo "[SUMMARY] DRY_RUN: ${params.DRY_RUN}"
                    echo "[SUMMARY] Plan Only: ${params.PLAN_DRY_RUN}"
                    echo "[SUMMARY] Total Assignments: ${assignmentCount}"
                    echo "[SUMMARY] Target Controllers: ${controllerTargets.join(', ')}"
                    echo "[SUMMARY] Failures: ${env.FAILURE_COUNT}"
                }
            }
        }
    }
    post {
        always {
            cleanWs()
        }
        success {
            echo "[DONE] Migration pipeline completed successfully."
        }
        failure {
            echo "[ERROR] Migration failed. Check logs for details."
        }
    }
}